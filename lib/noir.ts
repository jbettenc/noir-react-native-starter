import {NativeModules, Platform} from 'react-native';
import {Circuit, Parameter, ParameterType} from '../types';
const {NoirModule: Noir} = NativeModules;

/**
 * Load the SRS from the resources into the internal storage
 * so it can be used for proof generation and verification
 * Only needed for Android.
 * This assumes the SRS is in the /android/app/src/main/res/raw folder
 * otherwise it does nothing and the SRS will be downloaded on the fly
 * from Aztec's server
 */
export async function prepareSrs() {
  // Only needed for Android
  if (Platform.OS === 'android') {
    await Noir.prepareSrs();
  }
}

/**
 * Deserialize a circuit from the JSON manifest file
 * and setup the SRS for this circuit
 * @param circuit The circuit to setup
 * @param size The size of the circuit
 * @param lowMemoryMode Whether to use low memory mode
 * @returns The ID of the circuit
 */
export async function setupCircuit(
  circuit: Circuit,
  size?: number,
  lowMemoryMode?: boolean,
) {
  const {circuitId} = await Noir.setupCircuit(
    JSON.stringify(circuit),
    // Default to subgroup 2^20 if size is not provided
    size ?? 1048576,
    lowMemoryMode ?? false,
  );
  return circuitId as string;
}

function computeInputArraySize(type: ParameterType) {
  let count = 0;
  if (type.type && type.type.kind === 'array') {
    count += (type.length || 0) * computeInputArraySize(type.type);
  } else {
    count += type.length || 0;
  }
  return count;
}

function computePublicInputsSize(params: Parameter[]) {
  let fieldCount = 0;
  for (let param of params) {
    if (param.visibility === 'private') {
      continue;
    }
    if (param.type.kind === 'array') {
      fieldCount += computeInputArraySize(param.type);
    } else if (param.type.kind === 'string') {
      fieldCount += param.type.length || 0;
    } else if (param.type.kind === 'struct') {
      fieldCount += computePublicInputsSize(param.type.fields!);
    } else {
      fieldCount += 1;
    }
  }
  return fieldCount;
}

function getLastIndexOfPublicInputs(circuit: Circuit) {
  // Each field is encoded as a hexadecimal string of 64 characters (i.e. 32 bytes)
  return 64 * 3 + 8 + computePublicInputsSize(circuit.abi.parameters) * 64;
}

/**
 * **WARNING: Not guaranteed to work with Honk proofs for now**
 *
 * Extract the public inputs from the proofs
 * @param circuit The circuit the proof is associated with
 * @param proofWithPublicInputs The proof containing the public inputs
 * @returns The raw public inputs
 */
export function extractRawPublicInputs(
  circuit: Circuit,
  proofWithPublicInputs: string,
) {
  const lastIndex = getLastIndexOfPublicInputs(circuit);
  return proofWithPublicInputs.slice(64 * 3 + 8, lastIndex);
}

/**
 * **WARNING: Not guaranteed to work with Honk proofs for now**
 *
 * Extract the proof from the proof including public inputs by getting
 * rid of the public inputs
 * @param circuit The circuit the proof is associated with
 * @param proofWithPublicInputs The proof containing the public inputs
 * @returns The proof
 */
export function extractProof(circuit: Circuit, proofWithPublicInputs: string) {
  const lastIndex = getLastIndexOfPublicInputs(circuit);
  return (
    proofWithPublicInputs.slice(8, 8 + 64 * 3) +
    proofWithPublicInputs.slice(lastIndex)
  );
}

/**
 * Generate a proof for the given inputs and circuit
 * @param inputs The inputs to the circuit
 * @param circuit If not preloaded, provide the JSON manifest file of the Noir circuit generated by nargo
 * @returns The proof
 */
export async function generateProof(
  inputs: {[key: string]: any},
  circuitId: string,
  vkey: string,
) {
  const {proof} = await Noir.prove(inputs, circuitId, vkey);

  return {
    // This is the full proof, including the public inputs
    proofWithPublicInputs: proof,
  };
}

/**
 * Verify a proof using the given verification key
 * @param proofWithPublicInputs The proof (including public inputs) to verify
 * @param circuit If not loaded before, either with the preloading function or the prove function,
 * then make sure to provide the JSON manifest file of the Noir circuit generated by nargo
 * @returns Whether the proof is valid
 */
export async function verifyProof(
  proofWithPublicInputs: string,
  circuitId: string,
  vkey: string,
) {
  const {verified} = await Noir.verify(proofWithPublicInputs, circuitId, vkey);
  return verified;
}

export async function execute(inputs: {[key: string]: any}, circuitId: string) {
  const {witness} = await Noir.execute(inputs, circuitId);
  return witness as string[];
}

export async function generateVkey(circuitId: string) {
  const {vkey} = await Noir.generateVkey(circuitId);
  return vkey;
}

/**
 * Remove a previously setup circuit from memory
 * @param circuitId The ID of the circuit to remove from memory
 */
export async function clearCircuit(circuitId: string) {
  await Noir.clearCircuit(circuitId);
}

/**
 * Remove all previously setup circuits from memory
 */
export async function clearAllCircuits() {
  await Noir.clearAllCircuits();
}
